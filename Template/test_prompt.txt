import mock
import importlib
from io import StringIO
import requests
import sys
import multiprocessing
import time

first = True

class InputExceededError(Exception):
    pass

def run_test(inputs):
    output = StringIO()
    sys.stdout = output
    def side_effect(*args, **kwargs):
        if side_effect.counter < len(inputs):
            result = inputs[side_effect.counter]
            side_effect.counter += 1
            return result
        raise InputExceededError("Plus d'inputs demandes que fournis")
    side_effect.counter = 0

    with mock.patch('builtins.input', side_effect=side_effect):
        try:
            import user  # Recharger le module utilisateur pour chaque test
        except InputExceededError as e:
            return str(e)
        except Exception as e:
            return f"Erreur non geree : {str(e)}"
        finally:
            sys.stdout = sys.__stdout__
    actual_output = output.getvalue().strip()
    return actual_output

def run_test(inputs, expected_output):
    output = StringIO()
    sys.stdout = output
    def side_effect(*args, **kwargs):
        if side_effect.counter < len(inputs):
            result = inputs[side_effect.counter]
            side_effect.counter += 1
            return result
        raise InputExceededError("Plus d'inputs demandes que fournis")
    side_effect.counter = 0

    with mock.patch('builtins.input', side_effect=side_effect):
        try:
            importlib.reload(user)  # Recharger le module utilisateur pour chaque test
        except InputExceededError as e:
            return str(e)
        except Exception as e:
            return "autre"
        finally:
            sys.stdout = sys.__stdout__

          # Recharger le module utilisateur pour chaque test
    actual_output = output.getvalue().strip()
    return actual_output == expected_output

def run_test_1(inputs, expected_output):
    output = StringIO()
    sys.stdout = output
    def side_effect(*args, **kwargs):
        if side_effect.counter < len(inputs):
            result = inputs[side_effect.counter]
            side_effect.counter += 1
            return result
        raise InputExceededError("Plus d'inputs demandes que fournis")
    side_effect.counter = 0

    with mock.patch('builtins.input', side_effect=side_effect):
        try:
            import user  # Recharger le module utilisateur pour chaque test
        except InputExceededError as e:
            return str(e)
        except Exception as e:
            return "autre"
        finally:
            sys.stdout = sys.__stdout__

          # Recharger le module utilisateur pour chaque test
    actual_output = output.getvalue().strip()
    return actual_output == expected_output

def run_in_process(queue, inputs, expected_output):
    global first
    if first == True:
        result = run_test_1(inputs, expected_output)
        first = False
    else:
        result = run_test(inputs, expected_output)
    queue.put(result)

def perform_test(inputs, expected_output, timeout):
    queue = multiprocessing.Queue()
    process = multiprocessing.Process(target=run_in_process, args=(queue, inputs, expected_output))
    process.start()
    process.join(timeout)
    if process.is_alive():
        process.terminate()
        return "Timeout"
    else:
        return queue.get()

def main():
    gold = sys.argv[1]
    id = sys.argv[2]
    ok = True
    tests = [
        #tests

    ]
    timeout = 2  # Temps limite en secondes pour chaque test

    for inputs, expected_output in tests:
        result = perform_test(inputs, expected_output, timeout)
        if not result:
            print('non')
            ok = False
        elif result == "Timeout":
            print("Il y a surement une boucle infinie, verfie ton code")
            ok = False
            break
        elif result == "Plus d'inputs demandes que fournis":
            print(result)
            ok = False
            break
        elif result == "autre":
            print(result)
            ok = False
            break
        else:
            print('Correct')

    url = 'http://127.0.0.1:5000/update_mission_state'
    myobj = {'player_id': id, 'state': ok, 'gold': gold}
    x = requests.post(url, json=myobj)

if __name__ == '__main__':
    main()
